name,ring,quadrant,status,description
GitHub Copilot,adopt,tools,no change,"<p><strong>GitHub Copilot</strong> has matured significantly since its introduction and is now a staple in many development teams. It provides AI-powered code suggestions directly in your IDE, dramatically reducing boilerplate code and accelerating development velocity.</p><p>Our teams report 30-40% productivity improvements for routine coding tasks. The recent addition of Copilot Chat brings conversational AI directly into the development workflow, allowing developers to ask questions about codebases and get contextual help.</p><p>We recommend establishing team guidelines around code review for AI-generated code and being mindful of licensing implications for training data. For enterprise adoption, GitHub Copilot Business provides additional security controls and policy management.</p><p><a href=""#"">Read more about AI-Assisted Development Guidelines →</a></p>"
Docker,adopt,tools,no change,"<p><strong>Docker</strong> remains the foundational container platform that transformed how we build, ship, and run applications. Its ubiquity across development and production environments makes it an essential skill for modern software teams.</p><p>While Kubernetes dominates orchestration, Docker's role in local development, CI/CD pipelines, and as the underlying container runtime continues to be critical. Docker Compose remains excellent for local multi-service development environments.</p><p>Recent improvements to Docker Desktop, including the integrated Kubernetes cluster and extensions marketplace, have strengthened its position as the go-to local development tool. Be aware of Docker Desktop licensing requirements for enterprise use.</p><p><a href=""#"">Read more about Container Strategy →</a></p>"
Kubernetes,adopt,tools,no change,"<p><strong>Kubernetes</strong> has become the de facto standard for container orchestration. Its declarative approach to infrastructure and rich ecosystem of tools make it the foundation for cloud-native architectures.</p><p>For most teams, we recommend using managed Kubernetes services (AKS, EKS, GKE) rather than self-managing clusters. The operational overhead of running your own control plane rarely provides sufficient value outside of specific compliance or sovereignty requirements.</p><p>Focus on building strong GitOps practices around Kubernetes deployments. Tools like ArgoCD and Flux provide excellent declarative deployment pipelines that improve reliability and auditability.</p><p><a href=""#"">Read more about Platform Architecture →</a></p>"
Terraform,adopt,tools,moved in,"<p><strong>Terraform</strong> has earned its place in Adopt after years of proven reliability across diverse infrastructure scenarios. Its declarative HCL syntax, extensive provider ecosystem, and state management capabilities make it the leading Infrastructure as Code tool.</p><p>The recent concerns around HashiCorp's licensing changes led to the creation of OpenTofu, which we're watching in Trial. However, Terraform's maturity, ecosystem, and HashiCorp's enterprise support still make it the safer choice for most organisations today.</p><p>We strongly recommend implementing remote state with locking (using S3+DynamoDB, Azure Storage, or Terraform Cloud), establishing module libraries for common patterns, and integrating plan output into pull request reviews.</p><p><a href=""#"">Read more about Infrastructure as Code Standards →</a></p>"
VS Code,adopt,tools,no change,"<p><strong>Visual Studio Code</strong> has become the dominant code editor across nearly all programming languages and platforms. Its extension ecosystem, integrated terminal, and excellent Git integration provide a complete development environment.</p><p>The addition of Remote Development capabilities (containers, SSH, WSL) has been transformative for teams needing consistent development environments. GitHub Codespaces builds on this foundation for cloud-based development.</p><p>We recommend establishing team-wide extension recommendations and settings sync to ensure consistent development experiences. The upcoming native AI features through Copilot integration will further cement VS Code's position.</p><p><a href=""#"">Read more about Developer Environment Setup →</a></p>"
Grafana,adopt,tools,no change,"<p><strong>Grafana</strong> continues to be our preferred visualisation platform for metrics and observability data. Its ability to query multiple data sources, create rich dashboards, and set up alerting makes it central to our monitoring strategy.</p><p>The Grafana stack (Loki for logs, Tempo for traces, Mimir for metrics) provides a compelling open-source alternative to commercial observability platforms. Grafana Cloud offers a managed option for teams wanting to reduce operational burden.</p><p>Focus on creating actionable dashboards rather than vanity metrics. Implement dashboard-as-code practices using Grafana's provisioning capabilities or tools like Grafonnet.</p><p><a href=""#"">Read more about Observability Strategy →</a></p>"
GitHub Actions,adopt,tools,no change,"<p><strong>GitHub Actions</strong> has become our default CI/CD platform for teams using GitHub. The tight integration with repositories, marketplace of reusable actions, and generous free tier for public repositories make it an excellent choice.</p><p>The workflow syntax is intuitive, and the ability to compose workflows from reusable actions accelerates pipeline development. Matrix builds simplify cross-platform and multi-version testing.</p><p>Be mindful of secrets management and use OIDC authentication for cloud provider access rather than long-lived credentials. Consider self-hosted runners for sensitive workloads or specialised hardware requirements.</p><p><a href=""#"">Read more about CI/CD Pipeline Patterns →</a></p>"
Playwright,adopt,tools,moved in,"<p><strong>Playwright</strong> has moved to Adopt based on consistently positive experiences across our teams. Microsoft's end-to-end testing framework offers excellent cross-browser support, auto-wait capabilities, and powerful debugging tools.</p><p>Compared to Cypress, Playwright provides true multi-browser testing (including Safari via WebKit), better iframe and multi-tab support, and can test across multiple browser contexts simultaneously. The API testing capabilities allow combining UI and API tests in a single framework.</p><p>The Playwright Test runner includes features like parallel execution, visual comparisons, and trace viewing that significantly improve test development and debugging. We recommend it as the default choice for new E2E testing initiatives.</p><p><a href=""#"">Read more about Testing Strategy →</a></p>"
Claude AI,trial,tools,new,"<p><strong>Claude</strong> from Anthropic represents a significant advancement in AI assistants for software development. Its strong reasoning capabilities, large context window (200K tokens), and nuanced understanding of code make it particularly effective for complex programming tasks.</p><p>We're using Claude for code review assistance, documentation generation, architecture discussions, and debugging complex issues. The Claude API enables integration into development workflows and custom tooling.</p><p>While still evaluating long-term reliability and comparing with alternatives like GPT-4 and Gemini, early results are promising. Consider establishing guidelines for appropriate use cases and data handling when using AI assistants.</p><p><a href=""#"">Read more about AI-Assisted Development Guidelines →</a></p>"
Cursor,trial,tools,new,"<p><strong>Cursor</strong> is an AI-first code editor built on VS Code that deeply integrates AI capabilities throughout the editing experience. It goes beyond simple code completion to offer contextual chat, codebase-wide understanding, and intelligent refactoring suggestions.</p><p>The ability to reference files and documentation in conversations, combined with the familiar VS Code interface, provides a compelling developer experience. Cursor's approach of understanding your entire codebase enables more relevant and accurate suggestions.</p><p>We're trialling Cursor alongside traditional VS Code + Copilot setups to evaluate the productivity benefits of deeper AI integration. Early feedback suggests significant benefits for understanding unfamiliar codebases and complex refactoring tasks.</p><p><a href=""#"">Read more about Developer Tooling Evaluation →</a></p>"
OpenTofu,trial,tools,new,"<p><strong>OpenTofu</strong> emerged as an open-source fork of Terraform following HashiCorp's license change to BSL. Maintained by the Linux Foundation, it provides a community-driven alternative that remains truly open-source.</p><p>OpenTofu maintains compatibility with Terraform configurations and providers, making migration straightforward. The community has been active in adding features and maintaining parity with Terraform releases.</p><p>We're evaluating OpenTofu for new projects and assessing migration paths for existing Terraform infrastructure. While promising, organisations should consider the maturity trade-offs against Terraform's established ecosystem and enterprise support.</p><p><a href=""#"">Read more about Infrastructure as Code Standards →</a></p>"
Trivy,trial,tools,moved in,"<p><strong>Trivy</strong> has moved to Trial based on its comprehensive vulnerability scanning capabilities and ease of integration. It scans container images, filesystems, git repositories, and Kubernetes clusters for vulnerabilities, misconfigurations, and secrets.</p><p>Unlike tools focused solely on container scanning, Trivy provides a unified approach to security scanning across multiple artifact types. Its SBOM generation capabilities support software supply chain security requirements.</p><p>Integration into CI/CD pipelines is straightforward, and the scan speed makes it practical for developer workflows. Consider Trivy as part of a defence-in-depth security strategy rather than a complete solution.</p><p><a href=""#"">Read more about Security Scanning Standards →</a></p>"
k9s,trial,tools,no change,"<p><strong>k9s</strong> provides a terminal-based UI for managing Kubernetes clusters that significantly improves the experience over raw kubectl commands. Its intuitive navigation, real-time updates, and powerful filtering make cluster exploration and troubleshooting faster.</p><p>For developers and operators working regularly with Kubernetes, k9s reduces cognitive load and accelerates common tasks like viewing logs, describing resources, and managing deployments.</p><p>While not replacing the need to understand kubectl and Kubernetes fundamentals, k9s is an excellent productivity tool for day-to-day cluster operations.</p><p><a href=""#"">Read more about Kubernetes Operations Guide →</a></p>"
Pulumi,trial,tools,no change,"<p><strong>Pulumi</strong> offers Infrastructure as Code using general-purpose programming languages like TypeScript, Python, Go, and C#. This approach enables using familiar languages, testing frameworks, and IDE features for infrastructure development.</p><p>For teams with strong software engineering practices, Pulumi's programming model can be more intuitive than HCL. The ability to use loops, conditionals, and abstractions from your language of choice enables sophisticated infrastructure patterns.</p><p>However, consider whether your team benefits from Terraform's more constrained DSL, which can make infrastructure code more accessible to non-developers. Pulumi shines when infrastructure complexity warrants software engineering techniques.</p><p><a href=""#"">Read more about Infrastructure as Code Standards →</a></p>"
Backstage,trial,tools,no change,"<p><strong>Backstage</strong> is Spotify's open-source platform for building developer portals. It provides a centralised place for service catalogues, documentation, and developer tooling through a plugin architecture.</p><p>For organisations pursuing platform engineering, Backstage offers a foundation for creating a unified developer experience. The software catalogue provides visibility into services, ownership, and dependencies.</p><p>Adoption requires investment in customisation and content creation. Success depends on treating Backstage as a product with ongoing development rather than a one-time deployment. Start with the service catalogue and documentation before expanding to additional plugins.</p><p><a href=""#"">Read more about Platform Engineering Strategy →</a></p>"
Tailscale,assess,tools,new,"<p><strong>Tailscale</strong> builds on WireGuard to provide zero-configuration VPN connectivity between devices and services. Its mesh networking approach and identity-based access control simplify secure connectivity across diverse environments.</p><p>We're evaluating Tailscale for scenarios including secure access to development environments, connecting hybrid cloud resources, and replacing traditional VPN solutions. The ease of setup and management is compelling compared to traditional VPN infrastructure.</p><p>Consider Tailscale for teams struggling with VPN complexity or needing secure connectivity across cloud providers. The free tier is generous for evaluation and small team use.</p><p><a href=""#"">Read more about Network Security Architecture →</a></p>"
Zed,assess,tools,new,"<p><strong>Zed</strong> is a high-performance code editor built from the ground up in Rust by the creators of Atom. It focuses on speed, with instant startup, smooth scrolling, and responsive editing even in large files.</p><p>Native collaboration features enable real-time pair programming without screen sharing. The AI integration approach treats the assistant as a peer in your editor rather than an autocomplete feature.</p><p>We're assessing Zed as a potential VS Code alternative for developers prioritising performance. Currently macOS-only with Linux in beta, Windows support is planned.</p><p><a href=""#"">Read more about Developer Tooling Evaluation →</a></p>"
Ollama,assess,tools,new,"<p><strong>Ollama</strong> enables running large language models locally with a simple command-line interface. It supports models like Llama 2, Mistral, and Code Llama, making local AI experimentation accessible.</p><p>For teams with privacy concerns about sending code to external AI services, Ollama provides an alternative for local development assistance. Performance depends on hardware, with Apple Silicon Macs providing good experiences.</p><p>We're evaluating Ollama for use cases where data sensitivity prevents using cloud AI services. Consider the trade-offs between local model capabilities and cloud services like GPT-4 or Claude.</p><p><a href=""#"">Read more about AI-Assisted Development Guidelines →</a></p>"
Warp,assess,tools,no change,"<p><strong>Warp</strong> reimagines the terminal with modern features including AI-powered command suggestions, command blocks, and collaborative features. The IDE-like experience brings improved productivity to command-line workflows.</p><p>Features like searchable command history, intelligent autocomplete, and the ability to share terminal sessions make Warp compelling for teams spending significant time in the terminal.</p><p>We're assessing whether the productivity benefits outweigh the dependency on a proprietary terminal application. Warp requires account creation, which may be a concern for some organisations.</p><p><a href=""#"">Read more about Developer Environment Setup →</a></p>"
Depot,assess,tools,new,"<p><strong>Depot</strong> provides managed container build infrastructure that significantly accelerates Docker builds in CI/CD pipelines. By running builds on dedicated, cached infrastructure, Depot reduces build times by 10-40x compared to typical CI runners.</p><p>For teams where container build time is a significant bottleneck, Depot's managed approach provides immediate benefits without infrastructure management overhead.</p><p>We're evaluating Depot against alternatives like GitHub Actions larger runners and self-hosted build infrastructure. The pricing model based on build minutes makes cost predictable.</p><p><a href=""#"">Read more about CI/CD Pipeline Patterns →</a></p>"
Pkl,assess,tools,new,"<p><strong>Pkl</strong> is Apple's new configuration language designed to be safer and more maintainable than YAML or JSON. It provides validation, schemas, and IDE support while generating standard formats for consumption.</p><p>Pkl addresses common configuration pain points including type safety, modularity, and reducing duplication. The ability to generate YAML, JSON, and property files from a single source enables gradual adoption.</p><p>We're assessing Pkl for configuration-heavy projects where YAML complexity has become problematic. The language is new, so ecosystem tooling is still developing.</p><p><a href=""#"">Read more about Configuration Management Patterns →</a></p>"
Langfuse,hold,tools,new,"<p><strong>Langfuse</strong> provides open-source observability for LLM applications, including tracing, analytics, and prompt management. As organisations build more AI-powered features, understanding LLM behaviour becomes critical.</p><p>While the concept is valuable, Langfuse is still maturing. We've encountered stability issues and missing features in production deployments. The hosted version has more capabilities than self-hosted.</p><p>We recommend evaluating but not depending on Langfuse for production systems until it matures. Consider commercial alternatives like Datadog LLM Observability or Arize for production requirements.</p><p><a href=""#"">Read more about AI Observability Patterns →</a></p>"
Helm,hold,tools,moved out,"<p><strong>Helm</strong> has moved to Hold as we've found simpler alternatives for most Kubernetes deployment scenarios. While Helm's package management approach was revolutionary, the complexity of chart templating and upgrade semantics often creates more problems than it solves.</p><p>For application deployment, we now prefer Kustomize for its simpler overlay model, or raw manifests managed through GitOps tools like ArgoCD. For third-party software, Helm remains useful when it's the primary distribution method.</p><p>If using Helm, invest in understanding hooks, upgrade ordering, and rollback behaviour. Consider Helmfile for managing multiple releases. For new projects, evaluate whether you truly need Helm's capabilities.</p><p><a href=""#"">Read more about Kubernetes Deployment Patterns →</a></p>"
Microsoft Azure,adopt,platforms,no change,"<p><strong>Microsoft Azure</strong> is our recommended cloud platform for organisations with significant Microsoft ecosystem investments. The integration with Active Directory, Microsoft 365, and developer tools like Visual Studio and GitHub provides a cohesive experience.</p><p>Azure's hybrid cloud capabilities through Azure Arc and Azure Stack are particularly strong for enterprises with on-premises requirements. The compliance certifications and regional availability meet most regulatory requirements.</p><p>For .NET workloads, Azure provides first-class support and optimised services. Consider Azure when Microsoft ecosystem integration, hybrid scenarios, or specific compliance requirements are priorities.</p><p><a href=""#"">Read more about Cloud Platform Strategy →</a></p>"
Azure DevOps,adopt,platforms,no change,"<p><strong>Azure DevOps</strong> provides a complete DevOps toolchain including Azure Repos, Pipelines, Boards, Artifacts, and Test Plans. For organisations standardised on Microsoft technologies, it offers tight integration and familiar experiences.</p><p>Azure Pipelines supports any language and platform, with YAML-based pipeline definitions enabling pipeline-as-code practices. The integration with Azure services simplifies deployment to Azure resources.</p><p>For teams using GitHub, consider whether GitHub Actions provides sufficient CI/CD capabilities, as Microsoft's investment has shifted towards GitHub for developer workflows. Azure DevOps remains strong for organisations needing integrated project management and enterprise features.</p><p><a href=""#"">Read more about CI/CD Pipeline Patterns →</a></p>"
Microsoft 365,adopt,platforms,no change,"<p><strong>Microsoft 365</strong> continues to be the enterprise productivity standard. Teams, SharePoint, and the Office applications provide the collaboration foundation for most organisations.</p><p>The platform's evolution towards integrated experiences, with Teams as the hub for collaboration, has accelerated remote and hybrid work adoption. Power Platform integration enables citizen development and automation.</p><p>Invest in governance and security configuration, particularly around external sharing, guest access, and data loss prevention policies. The admin complexity is significant but necessary for enterprise deployments.</p><p><a href=""#"">Read more about Collaboration Platform Governance →</a></p>"
AWS,adopt,platforms,no change,"<p><strong>Amazon Web Services</strong> remains the leading cloud platform with the broadest service offerings and most mature ecosystem. Its global infrastructure, extensive service catalogue, and deep expertise availability make it the default choice for many organisations.</p><p>AWS's continuous innovation in areas like serverless, containers, and machine learning services provides capabilities that enable modern architectures. The depth of documentation, community knowledge, and third-party tooling is unmatched.</p><p>Consider AWS when service breadth, ecosystem maturity, and talent availability are priorities. Be mindful of cost management as AWS's flexibility can lead to unexpected bills without proper governance.</p><p><a href=""#"">Read more about Cloud Platform Strategy →</a></p>"
Vercel,adopt,platforms,moved in,"<p><strong>Vercel</strong> has moved to Adopt based on consistently excellent experiences for frontend deployment. The platform's focus on developer experience, combined with its Next.js integration, provides the best deployment experience for React applications.</p><p>Preview deployments for every pull request, automatic HTTPS, global CDN distribution, and edge functions are included by default. The analytics and monitoring capabilities have matured significantly.</p><p>For teams building with Next.js, Vercel is the obvious choice. For other frameworks, evaluate whether Vercel's framework-agnostic support meets your needs or consider alternatives like Netlify or Cloudflare Pages.</p><p><a href=""#"">Read more about Frontend Deployment Patterns →</a></p>"
Cloudflare,adopt,platforms,new,"<p><strong>Cloudflare</strong> has evolved from a CDN provider to a comprehensive edge computing platform. Workers for serverless compute, Pages for static site hosting, R2 for object storage, and D1 for edge databases enable building complete applications at the edge.</p><p>The zero-egress-fee model for R2 storage is particularly compelling compared to AWS S3. Workers provide a lightweight serverless model with global distribution and sub-millisecond cold starts.</p><p>We're adopting Cloudflare for edge workloads, static sites, and as an S3 alternative. The platform's aggressive pricing and developer focus make it compelling for many use cases.</p><p><a href=""#"">Read more about Edge Computing Architecture →</a></p>"
Azure OpenAI Service,trial,platforms,new,"<p><strong>Azure OpenAI Service</strong> provides enterprise access to OpenAI models including GPT-4, DALL-E, and embeddings with Azure's security, compliance, and enterprise features. For organisations requiring data residency, private endpoints, and enterprise agreements, it's the path to OpenAI capabilities.</p><p>The service provides content filtering, responsible AI features, and integration with Azure's identity and networking. Regional deployment options help meet data sovereignty requirements.</p><p>We're trialling Azure OpenAI for enterprise AI applications where OpenAI's direct API doesn't meet compliance requirements. Consider the trade-offs between feature availability lag and enterprise controls.</p><p><a href=""#"">Read more about AI Platform Strategy →</a></p>"
Supabase,trial,platforms,no change,"<p><strong>Supabase</strong> provides an open-source Firebase alternative built on PostgreSQL. It combines a managed Postgres database with authentication, real-time subscriptions, storage, and edge functions in a cohesive platform.</p><p>For teams wanting relational database capabilities with Firebase-like developer experience, Supabase offers compelling benefits. The auto-generated APIs from database schemas accelerate development.</p><p>Consider Supabase for applications where PostgreSQL's capabilities are valuable and you want a unified platform for common backend concerns. The self-hosted option provides flexibility for specific deployment requirements.</p><p><a href=""#"">Read more about Backend Platform Evaluation →</a></p>"
Railway,trial,platforms,new,"<p><strong>Railway</strong> provides a modern Platform-as-a-Service that simplifies application deployment. Its focus on developer experience, with features like automatic builds from Git, infrastructure provisioning, and environment management, reduces deployment complexity.</p><p>For teams finding Kubernetes too complex and Heroku too limited, Railway occupies an appealing middle ground. The template system enables quick starts with common stacks.</p><p>We're trialling Railway for smaller projects and internal tools where operational simplicity is valued over maximum flexibility. Evaluate pricing carefully for production workloads.</p><p><a href=""#"">Read more about Platform-as-a-Service Evaluation →</a></p>"
Neon,trial,platforms,new,"<p><strong>Neon</strong> provides serverless PostgreSQL with innovative features including database branching, autoscaling, and a generous free tier. The branching capability enables creating instant database copies for development and testing.</p><p>For development workflows, the ability to branch databases like code is transformative. Preview deployments can have their own database branches, enabling true isolation without data management overhead.</p><p>We're trialling Neon for development databases and smaller production workloads. Consider the maturity trade-offs against established managed PostgreSQL services for critical production databases.</p><p><a href=""#"">Read more about Database Platform Strategy →</a></p>"
PlanetScale,trial,platforms,moved out,"<p><strong>PlanetScale</strong> provides a MySQL-compatible serverless database platform with excellent branching and schema change workflows. The Vitess-based architecture enables horizontal scaling while maintaining MySQL compatibility.</p><p>Recent pricing changes and the elimination of the free tier have impacted its accessibility for smaller projects. The lack of foreign key support (a Vitess limitation) requires application-level referential integrity.</p><p>We've moved PlanetScale to a cautious trial position. Evaluate carefully whether the branching workflow benefits justify the constraints and cost compared to alternatives like managed MySQL or PostgreSQL services.</p><p><a href=""#"">Read more about Database Platform Strategy →</a></p>"
Fly.io,trial,platforms,no change,"<p><strong>Fly.io</strong> enables deploying applications close to users with its global edge infrastructure. The platform transforms Docker containers into lightweight VMs distributed across worldwide data centres.</p><p>For applications where latency matters globally, Fly.io's approach of running full application instances at the edge (rather than just static content) provides genuine benefits. The developer experience for deployment and scaling is excellent.</p><p>Consider Fly.io for globally distributed applications, particularly those with stateful requirements at the edge. Evaluate the operational model differences from traditional cloud deployment.</p><p><a href=""#"">Read more about Edge Computing Architecture →</a></p>"
Microsoft Fabric,assess,platforms,new,"<p><strong>Microsoft Fabric</strong> unifies data engineering, data science, real-time analytics, and business intelligence in a single platform built on OneLake. It represents Microsoft's vision for integrated analytics.</p><p>For organisations heavily invested in the Microsoft ecosystem, Fabric provides a cohesive alternative to assembling disparate data tools. The Power BI integration is seamless, and the lakehouse architecture enables diverse workloads.</p><p>We're assessing Fabric for its potential to simplify data platform architectures. Consider the platform lock-in trade-offs and evaluate whether the integrated experience justifies moving from best-of-breed tools.</p><p><a href=""#"">Read more about Data Platform Architecture →</a></p>"
Render,assess,platforms,no change,"<p><strong>Render</strong> provides a straightforward platform for deploying web services, static sites, and databases. Its focus on simplicity makes it accessible for teams without dedicated platform expertise.</p><p>For projects not requiring Kubernetes complexity, Render offers sensible defaults and automatic deployments from Git. The managed PostgreSQL and Redis services simplify common backend requirements.</p><p>Assess Render for projects where deployment simplicity is prioritised over maximum flexibility. Compare pricing and capabilities with alternatives like Railway and Fly.io for your specific requirements.</p><p><a href=""#"">Read more about Platform-as-a-Service Evaluation →</a></p>"
Deno Deploy,assess,platforms,new,"<p><strong>Deno Deploy</strong> provides edge-first serverless hosting for Deno and JavaScript applications. Built on the Deno runtime, it offers TypeScript-first development with modern JavaScript features.</p><p>The global distribution with sub-millisecond cold starts makes Deno Deploy compelling for latency-sensitive applications. Integration with the Deno ecosystem, including built-in testing and linting, provides a cohesive experience.</p><p>We're assessing Deno Deploy for edge computing use cases. Consider the ecosystem maturity trade-offs compared to Cloudflare Workers or Lambda@Edge for production applications.</p><p><a href=""#"">Read more about Edge Computing Architecture →</a></p>"
Modal,assess,platforms,new,"<p><strong>Modal</strong> simplifies running Python applications in the cloud with elegant infrastructure-as-code patterns. Define compute requirements directly in Python code, and Modal handles provisioning, scaling, and infrastructure management.</p><p>For data science and machine learning workloads, Modal's approach of co-locating infrastructure definition with code reduces the gap between local development and cloud execution.</p><p>We're assessing Modal for ML pipelines and batch processing workloads. The developer experience is excellent, but evaluate the platform's maturity and pricing model for production requirements.</p><p><a href=""#"">Read more about ML Platform Architecture →</a></p>"
Azure Container Apps,assess,platforms,moved in,"<p><strong>Azure Container Apps</strong> provides serverless container hosting with built-in KEDA-based autoscaling. It offers a middle ground between Azure App Service and full Kubernetes, with microservices features like Dapr integration.</p><p>For teams wanting container benefits without Kubernetes operational complexity, Container Apps provides managed scaling, ingress, and secrets management. The consumption-based pricing aligns costs with actual usage.</p><p>We've moved Container Apps to Assess based on growing maturity. Evaluate for microservices architectures where managed Kubernetes feels excessive but App Service is too constrained.</p><p><a href=""#"">Read more about Container Platform Strategy →</a></p>"
Heroku,hold,platforms,no change,"<p><strong>Heroku</strong> pioneered the modern PaaS experience but has stagnated while competitors innovated. The elimination of the free tier, combined with limited evolution of the platform, has reduced its competitiveness.</p><p>For legacy applications already on Heroku, migration may not be urgent, but evaluate alternatives for new projects. Railway, Render, and Fly.io offer better developer experiences at competitive prices.</p><p>If Heroku's specific features like Heroku Postgres, Review Apps, or Salesforce integration are requirements, it remains viable. Otherwise, consider alternatives for new development.</p><p><a href=""#"">Read more about Platform-as-a-Service Evaluation →</a></p>"
OpenShift,hold,platforms,no change,"<p><strong>OpenShift</strong> provides enterprise Kubernetes with additional features for developer experience, security, and operations. However, the abstraction layers often add complexity rather than reducing it.</p><p>For organisations with Red Hat relationships and specific enterprise requirements, OpenShift may be appropriate. However, we generally recommend managed Kubernetes services (AKS, EKS, GKE) for most scenarios.</p><p>The learning curve for OpenShift's specific concepts on top of Kubernetes fundamentals is significant. Evaluate whether the enterprise features justify the additional complexity and cost.</p><p><a href=""#"">Read more about Container Platform Strategy →</a></p>"
Platform Engineering,adopt,techniques,moved in,"<p><strong>Platform Engineering</strong> has matured from a trend to an established practice. Building internal developer platforms (IDPs) that provide self-service capabilities improves developer productivity while maintaining governance.</p><p>Successful platform engineering treats the platform as a product, with platform teams serving internal developers as customers. The focus is on reducing cognitive load and enabling teams to deliver value faster.</p><p>Start with understanding developer pain points rather than technology choices. Common starting points include standardised deployment pipelines, environment provisioning, and observability tooling. Measure success through developer satisfaction and lead time improvements.</p><p><a href=""#"">Read more about Platform Engineering Strategy →</a></p>"
Trunk-Based Development,adopt,techniques,no change,"<p><strong>Trunk-Based Development</strong> remains our recommended branching strategy for teams practicing continuous integration. Short-lived feature branches merged frequently to main enable fast feedback cycles and reduce integration pain.</p><p>Combined with feature flags for incomplete features and comprehensive automated testing, trunk-based development supports both rapid iteration and production stability.</p><p>For teams struggling with long-lived branches and merge conflicts, trunk-based development requires cultural change as much as technical change. Start with reducing branch lifetime before eliminating branches entirely.</p><p><a href=""#"">Read more about Source Control Patterns →</a></p>"
Infrastructure as Code,adopt,techniques,no change,"<p><strong>Infrastructure as Code</strong> is the foundation of modern operations practices. Defining infrastructure through version-controlled configuration enables reproducibility, auditability, and automation that manual processes cannot achieve.</p><p>Whether using Terraform, Pulumi, CloudFormation, or platform-specific tools, the principles of declarative definitions, version control, and automated application are essential.</p><p>Invest in testing infrastructure code, implementing proper state management, and establishing review processes. Treat infrastructure repositories with the same rigour as application code.</p><p><a href=""#"">Read more about Infrastructure as Code Standards →</a></p>"
GitOps,adopt,techniques,no change,"<p><strong>GitOps</strong> uses Git as the single source of truth for declarative infrastructure and application deployment. Tools like ArgoCD and Flux continuously reconcile cluster state with Git repository contents.</p><p>GitOps provides auditability (all changes through Git), reproducibility (cluster state matches repository), and recovery (restore from Git history). It's particularly powerful for Kubernetes environments.</p><p>Implement GitOps incrementally, starting with application deployments before infrastructure. Establish clear repository structures and promotion workflows between environments.</p><p><a href=""#"">Read more about GitOps Implementation Guide →</a></p>"
Design Systems,adopt,techniques,no change,"<p><strong>Design Systems</strong> provide reusable component libraries with design tokens ensuring consistent user experiences across applications. They bridge design and development, enabling faster iteration with brand consistency.</p><p>Successful design systems require ongoing investment and treating the system as a product. The component library alone isn't sufficient; documentation, contribution guidelines, and governance are equally important.</p><p>Start with auditing existing patterns before building new components. Focus on high-impact, frequently-used components first. Storybook remains the leading tool for component documentation and development.</p><p><a href=""#"">Read more about Design System Architecture →</a></p>"
Zero Trust Security,adopt,techniques,moved in,"<p><strong>Zero Trust Security</strong> has moved to Adopt as the security model becomes standard practice. The principle of 'never trust, always verify' assumes no implicit trust based on network location or prior authentication.</p><p>Implementing zero trust involves identity-aware proxies, continuous authentication, least-privilege access, and microsegmentation. Tools like Cloudflare Access, Tailscale, and identity providers enable practical implementation.</p><p>Zero trust is a journey, not a destination. Start with identifying sensitive resources, implementing strong authentication, and gradually removing network-based trust assumptions.</p><p><a href=""#"">Read more about Security Architecture Patterns →</a></p>"
AI-Assisted Development,trial,techniques,new,"<p><strong>AI-Assisted Development</strong> encompasses using AI tools throughout the development lifecycle, from code completion to testing, documentation, and code review. This represents a fundamental shift in how developers work.</p><p>Tools like GitHub Copilot, Claude, and Cursor augment developer capabilities for routine tasks while requiring judgment for complex problems. The productivity gains are significant for experienced developers who can evaluate AI suggestions.</p><p>Establish team guidelines around AI tool usage, code review for AI-generated code, and appropriate use cases. Junior developers should understand fundamentals before relying heavily on AI assistance.</p><p><a href=""#"">Read more about AI-Assisted Development Guidelines →</a></p>"
Retrieval Augmented Generation,trial,techniques,new,"<p><strong>Retrieval Augmented Generation (RAG)</strong> enhances LLM responses by retrieving relevant context from knowledge bases before generation. This approach enables AI applications with access to current, domain-specific information.</p><p>RAG architectures involve embedding documents, storing in vector databases, retrieving relevant chunks based on queries, and including context in LLM prompts. This enables chatbots, search, and analysis over private data.</p><p>We're applying RAG for internal documentation search, customer support, and code understanding. Key challenges include chunking strategies, relevance ranking, and handling contradictory information.</p><p><a href=""#"">Read more about AI Architecture Patterns →</a></p>"
Feature Flags,trial,techniques,no change,"<p><strong>Feature Flags</strong> decouple deployment from release, enabling safer rollouts and experimentation. By controlling feature availability through configuration, teams can deploy incomplete features and gradually expose them to users.</p><p>Beyond simple toggles, feature management platforms like LaunchDarkly, Split, and open-source Unleash provide targeting, experimentation, and operational controls. The ability to instantly disable problematic features improves incident response.</p><p>Implement feature flag lifecycle management to avoid accumulating technical debt from unused flags. Establish conventions for flag naming, ownership, and cleanup.</p><p><a href=""#"">Read more about Feature Flag Patterns →</a></p>"
Domain-Driven Design,trial,techniques,no change,"<p><strong>Domain-Driven Design</strong> provides patterns for tackling complex software by focusing on the core domain and domain logic. The emphasis on ubiquitous language and bounded contexts helps teams build models that reflect business reality.</p><p>DDD is most valuable for complex domains where the business logic is the competitive advantage. For simpler CRUD applications, the overhead of strategic DDD patterns may not be justified.</p><p>Start with Event Storming workshops to discover domain boundaries and events. Focus on getting the model right rather than applying tactical patterns prematurely.</p><p><a href=""#"">Read more about Domain-Driven Design Guide →</a></p>"
Event Sourcing,trial,techniques,no change,"<p><strong>Event Sourcing</strong> stores state changes as a sequence of events rather than current state snapshots. This provides a complete audit trail, enables temporal queries, and supports rebuilding state at any point in time.</p><p>Event sourcing shines for domains requiring auditability, complex state transitions, or event-driven architectures. However, the complexity of event schemas, projections, and eventual consistency is significant.</p><p>Consider event sourcing carefully rather than as a default architecture. Hybrid approaches, using event sourcing for specific aggregates while maintaining traditional storage elsewhere, can provide benefits with manageable complexity.</p><p><a href=""#"">Read more about Event-Driven Architecture Patterns →</a></p>"
FinOps,trial,techniques,moved in,"<p><strong>FinOps</strong> brings financial accountability to cloud spending through collaboration between finance, technology, and business teams. As cloud costs become significant budget items, optimising spend while enabling innovation is critical.</p><p>FinOps practices include cost visibility and allocation, optimisation opportunities (right-sizing, reserved capacity, spot instances), and governance policies. Tools like CloudHealth, Spot.io, and cloud-native cost management features support implementation.</p><p>Start with tagging strategies for cost allocation and establishing visibility dashboards. Create accountability by surfacing costs to engineering teams alongside their technical metrics.</p><p><a href=""#"">Read more about FinOps Implementation Guide →</a></p>"
Cell-Based Architecture,assess,techniques,new,"<p><strong>Cell-Based Architecture</strong> decomposes systems into isolated cells that can fail independently without affecting other cells. This pattern improves resilience by containing blast radius and enabling independent scaling.</p><p>Each cell contains a complete vertical slice of the application, including compute, data, and dependencies. Routing layers direct traffic to cells based on customer or workload partitioning.</p><p>We're assessing cell-based architecture for high-availability requirements where regional failover isn't sufficient. The complexity of implementing cells requires significant engineering investment.</p><p><a href=""#"">Read more about Resilience Architecture Patterns →</a></p>"
Micro Frontends,assess,techniques,no change,"<p><strong>Micro Frontends</strong> extend microservices patterns to frontend development, enabling independent development, deployment, and scaling of frontend components. Different teams can own complete vertical slices including their UI.</p><p>Implementation approaches include runtime composition (Module Federation, single-spa), build-time composition, and server-side composition. Each has trade-offs around complexity, performance, and developer experience.</p><p>Micro frontends add significant complexity and should be reserved for large organisations where team autonomy benefits outweigh integration costs. Most teams are better served by a well-structured monolithic frontend.</p><p><a href=""#"">Read more about Frontend Architecture Patterns →</a></p>"
Contract Testing,assess,techniques,no change,"<p><strong>Contract Testing</strong> verifies that services adhere to agreed-upon API contracts, catching integration issues without requiring full end-to-end environments. Tools like Pact enable consumer-driven contract testing.</p><p>Contract tests are faster and more reliable than end-to-end tests while providing stronger guarantees than unit tests alone. They're particularly valuable for microservices architectures with many integration points.</p><p>Implement contract testing when integration test maintenance becomes burdensome. Start with critical service boundaries and establish clear ownership for contract management.</p><p><a href=""#"">Read more about Testing Strategy →</a></p>"
WebAssembly on Server,assess,techniques,new,"<p><strong>WebAssembly on Server</strong> runs Wasm modules in server environments for portable, sandboxed execution. This enables polyglot applications, plugin systems, and edge computing scenarios with near-native performance.</p><p>Runtimes like Wasmtime, WasmEdge, and Spin enable server-side Wasm execution. The WebAssembly Component Model aims to standardise module composition and capability-based security.</p><p>We're assessing server-side Wasm for plugin architectures and edge computing. The ecosystem is maturing but still requires careful evaluation for production workloads.</p><p><a href=""#"">Read more about WebAssembly Architecture Patterns →</a></p>"
AI Agents,assess,techniques,new,"<p><strong>AI Agents</strong> are autonomous AI systems that can plan, reason, and execute multi-step tasks using tools. Unlike simple prompt-response interactions, agents can break down goals, use APIs, and iterate toward objectives.</p><p>Frameworks like LangChain, AutoGPT, and Claude's tool use enable building agentic applications. Use cases include research assistants, coding agents, and workflow automation.</p><p>We're assessing AI agents for appropriate use cases while being cautious about autonomy levels. Human oversight, bounded actions, and clear termination conditions are essential for production agent deployments.</p><p><a href=""#"">Read more about AI Agent Architecture →</a></p>"
Blockchain for Enterprise,hold,techniques,no change,"<p><strong>Blockchain for Enterprise</strong> remains in Hold as most enterprise blockchain initiatives have failed to deliver promised value. The technology adds complexity while the decentralisation benefits rarely apply to enterprise contexts.</p><p>Most problems blockchain claims to solve are better addressed with traditional databases, event sourcing, or existing trust mechanisms. The overhead of consensus protocols rarely justifies the benefits within trusted enterprise environments.</p><p>Before blockchain, ask whether the use case requires decentralised trust among untrusted parties. If not, simpler solutions likely suffice.</p><p><a href=""#"">Read more about Technology Evaluation Framework →</a></p>"
Microservices for Small Teams,hold,techniques,no change,"<p><strong>Microservices for Small Teams</strong> remains in Hold. The operational complexity of distributed systems—networking, observability, deployment, data consistency—overwhelms small teams without proportional benefits.</p><p>A well-structured monolith with clear module boundaries provides most microservices benefits without the operational overhead. Extract services only when specific scalability, technology, or team boundaries require it.</p><p>Focus on good architecture within your deployment unit rather than distributing complexity. The ability to deploy independently is rarely the bottleneck for small teams.</p><p><a href=""#"">Read more about Architecture Decision Framework →</a></p>"
TypeScript,adopt,languages & frameworks,no change,"<p><strong>TypeScript</strong> has become the default for modern JavaScript development. The type system catches errors at compile time, improves IDE support, and serves as documentation for code interfaces.</p><p>The ecosystem has fully embraced TypeScript, with major frameworks and libraries providing first-class type definitions. The investment in learning TypeScript pays dividends in reduced debugging and improved refactoring confidence.</p><p>For new JavaScript projects, start with TypeScript. For existing projects, gradual migration using the allowJs option enables incremental adoption.</p><p><a href=""#"">Read more about TypeScript Standards →</a></p>"
React,adopt,languages & frameworks,no change,"<p><strong>React</strong> remains the dominant library for building component-based user interfaces. Its declarative model, rich ecosystem, and large community make it the safe choice for frontend development.</p><p>The React 18 release brought concurrent features and Suspense improvements. Server Components in frameworks like Next.js represent the future direction of React development.</p><p>For new projects, consider frameworks like Next.js or Remix rather than bare React. They provide routing, data fetching, and server-side rendering patterns that most applications need.</p><p><a href=""#"">Read more about Frontend Architecture Patterns →</a></p>"
Next.js,adopt,languages & frameworks,no change,"<p><strong>Next.js</strong> provides the best React development experience with server-side rendering, static generation, API routes, and excellent developer tooling. The App Router introduced in version 13 brings React Server Components to practical use.</p><p>The framework's convention-based approach reduces configuration while enabling sophisticated optimizations. Integration with Vercel provides seamless deployment, though Next.js runs well on other platforms.</p><p>For most React applications, Next.js is the recommended starting point. Evaluate whether you need its full-stack capabilities or whether a simpler setup suffices for your use case.</p><p><a href=""#"">Read more about React Framework Evaluation →</a></p>"
Python,adopt,languages & frameworks,no change,"<p><strong>Python</strong> dominates AI/ML, data science, and scripting while remaining capable for web development and automation. Its readable syntax and extensive library ecosystem make it accessible and powerful.</p><p>The AI boom has further elevated Python's importance, with frameworks like PyTorch, TensorFlow, and LangChain all Python-first. For data engineering and analysis, Python is often the only practical choice.</p><p>Invest in modern Python practices: type hints, virtual environments (or Poetry/PDM), and async capabilities. FastAPI represents modern Python web development patterns.</p><p><a href=""#"">Read more about Python Standards →</a></p>"
.NET 8,adopt,languages & frameworks,moved in,"<p><strong>.NET 8</strong> represents the maturation of Microsoft's cross-platform .NET vision. The performance improvements, minimal API enhancements, and native AOT compilation make .NET competitive for diverse workloads.</p><p>For enterprise applications, particularly those with Microsoft ecosystem requirements, .NET provides excellent developer productivity, strong tooling, and proven scalability. C# continues to evolve with features from functional programming.</p><p>The cross-platform story is now solid, with .NET running effectively on Linux containers and all major cloud platforms. Consider .NET for new backend services alongside traditional Microsoft-stack scenarios.</p><p><a href=""#"">Read more about .NET Development Standards →</a></p>"
Tailwind CSS,adopt,languages & frameworks,no change,"<p><strong>Tailwind CSS</strong> has changed how many teams approach styling. The utility-first approach enables rapid UI development directly in HTML/JSX without context-switching to separate CSS files.</p><p>Initial skepticism about readability has given way to appreciation for consistency and maintainability. The JIT compiler ensures production bundles contain only used utilities.</p><p>Tailwind pairs excellently with component-based frameworks. The design system through configuration file promotes consistency while the utility classes enable rapid prototyping and iteration.</p><p><a href=""#"">Read more about CSS Architecture Patterns →</a></p>"
Node.js,adopt,languages & frameworks,no change,"<p><strong>Node.js</strong> remains the JavaScript runtime powering countless web backends, APIs, and development tools. The ecosystem of npm packages and JavaScript's ubiquity make Node.js a practical choice for many scenarios.</p><p>Recent releases have improved performance, added native test runner capabilities, and enhanced security features. The ESM transition is largely complete, modernising the module system.</p><p>For JavaScript/TypeScript teams, Node.js enables full-stack development with a single language. Consider Bun for new projects wanting faster startup and bundling, while Node.js provides proven stability.</p><p><a href=""#"">Read more about Node.js Standards →</a></p>"
Go,adopt,languages & frameworks,no change,"<p><strong>Go</strong> excels for cloud-native services, CLI tools, and systems requiring high concurrency. Its simplicity, fast compilation, and efficient runtime make it excellent for infrastructure software.</p><p>The Go ecosystem has matured significantly, with strong libraries for common tasks and excellent Kubernetes/cloud native tooling largely written in Go. The language's stability means code written years ago still compiles and runs.</p><p>Consider Go for performance-critical services, infrastructure tooling, and scenarios where deployment simplicity (single binary) is valuable. The language's constraints can be frustrating but encourage consistent, maintainable code.</p><p><a href=""#"">Read more about Go Development Standards →</a></p>"
FastAPI,trial,languages & frameworks,moved in,"<p><strong>FastAPI</strong> has moved to Trial based on positive production experiences. The Python framework combines modern features—type hints, async support, automatic documentation—in a performant, developer-friendly package.</p><p>The automatic OpenAPI documentation generation, request validation, and IDE support from type hints significantly improve API development productivity. Performance approaches that of Node.js and Go for many workloads.</p><p>For new Python APIs, FastAPI is our default recommendation over Flask or Django REST Framework. The learning curve is gentle for developers familiar with Python type hints.</p><p><a href=""#"">Read more about API Development Patterns →</a></p>"
Rust,trial,languages & frameworks,no change,"<p><strong>Rust</strong> offers memory safety without garbage collection through its ownership system. The performance matches C/C++ while preventing entire categories of bugs at compile time.</p><p>Rust is increasingly adopted for infrastructure (ripgrep, exa, tools in this radar), WebAssembly, and performance-critical systems. The learning curve is significant but the compiler's guidance helps developers internalise ownership concepts.</p><p>Consider Rust when performance is critical and you can invest in the learning curve. For most application development, higher-level languages remain more productive.</p><p><a href=""#"">Read more about Systems Programming Evaluation →</a></p>"
htmx,trial,languages & frameworks,new,"<p><strong>htmx</strong> enables accessing modern browser features directly from HTML, building dynamic interfaces without writing JavaScript. It extends HTML with attributes for AJAX requests, CSS transitions, and WebSockets.</p><p>For applications where JavaScript framework complexity isn't warranted, htmx provides interactivity with server-rendered HTML. This approach simplifies architecture and enables backend developers to build dynamic UIs.</p><p>We're trialling htmx for admin interfaces, internal tools, and content-focused applications. Evaluate whether your team benefits from simplicity over the flexibility of JavaScript frameworks.</p><p><a href=""#"">Read more about Frontend Architecture Patterns →</a></p>"
Astro,trial,languages & frameworks,new,"<p><strong>Astro</strong> is a content-focused web framework that delivers excellent performance through its partial hydration architecture. Components are rendered to HTML by default, with JavaScript added only where needed.</p><p>Astro's island architecture allows mixing components from different frameworks (React, Vue, Svelte) in the same project. This flexibility enables gradual adoption and best-tool-for-job decisions.</p><p>For content-heavy sites, documentation, and marketing pages, Astro provides compelling performance benefits. Evaluate for projects where JavaScript bundle size and initial load performance are priorities.</p><p><a href=""#"">Read more about Static Site Framework Evaluation →</a></p>"
SvelteKit,trial,languages & frameworks,no change,"<p><strong>SvelteKit</strong> provides a full-stack framework for Svelte applications. Svelte's compile-time approach results in smaller bundles and better runtime performance compared to virtual DOM frameworks.</p><p>The developer experience is excellent, with intuitive syntax, built-in animations, and reactive declarations. SvelteKit adds routing, server-side rendering, and API endpoints.</p><p>For teams willing to invest in a smaller ecosystem, Svelte offers genuine productivity and performance benefits. The learning curve is gentle, especially for developers new to frontend frameworks.</p><p><a href=""#"">Read more about Frontend Framework Evaluation →</a></p>"
tRPC,trial,languages & frameworks,no change,"<p><strong>tRPC</strong> enables end-to-end typesafe APIs without code generation. By leveraging TypeScript's inference capabilities, tRPC provides API type safety between client and server without maintaining separate schemas.</p><p>For full-stack TypeScript applications, tRPC eliminates the API layer boilerplate while providing excellent developer experience through autocompletion and type checking.</p><p>tRPC works best in monorepo setups where client and server share TypeScript types. Evaluate the trade-offs of tightly coupling client and server versus schema-based approaches like GraphQL or OpenAPI.</p><p><a href=""#"">Read more about API Development Patterns →</a></p>"
Bun,trial,languages & frameworks,moved in,"<p><strong>Bun</strong> has moved to Trial based on rapid maturation and positive experiences. The JavaScript runtime offers significantly faster startup, built-in bundling, and npm compatibility while being largely Node.js compatible.</p><p>Bun's all-in-one approach (runtime, bundler, package manager, test runner) simplifies toolchains. The performance improvements are substantial for development workflows and serverless cold starts.</p><p>We're trialling Bun for new projects and development tooling. Node.js remains safer for production where maximum compatibility is required, but Bun's trajectory suggests it will become a viable production choice.</p><p><a href=""#"">Read more about JavaScript Runtime Evaluation →</a></p>"
Effect-TS,assess,languages & frameworks,new,"<p><strong>Effect-TS</strong> provides a TypeScript library for building typed, composable, and testable applications. It brings concepts from functional programming—algebraic effects, dependency injection, structured concurrency—to practical TypeScript development.</p><p>Effect's approach to error handling, dependency management, and async operations can significantly improve code reliability and testability. The learning curve is substantial but the patterns are powerful.</p><p>We're assessing Effect-TS for applications where reliability and testability are paramount. Consider it for complex backend services where TypeScript's default patterns feel insufficient.</p><p><a href=""#"">Read more about TypeScript Architecture Patterns →</a></p>"
Remix,assess,languages & frameworks,no change,"<p><strong>Remix</strong> is a full-stack React framework focusing on web standards and progressive enhancement. Now owned by Shopify, it provides an alternative philosophy to Next.js emphasising simplicity and web platform features.</p><p>Remix's approach to data loading, form handling, and error boundaries differs from Next.js. The framework excels when building progressively enhanced applications that work without JavaScript.</p><p>Assess Remix if web standards alignment and progressive enhancement are priorities. For most projects, Next.js's larger ecosystem and community may be more practical.</p><p><a href=""#"">Read more about React Framework Evaluation →</a></p>"
Qwik,assess,languages & frameworks,new,"<p><strong>Qwik</strong> takes a radical approach to web performance through resumability rather than hydration. Instead of re-executing JavaScript on load, Qwik resumes from the server-rendered state, enabling instant interactivity.</p><p>The architecture requires rethinking component patterns but delivers performance that's difficult to achieve with traditional frameworks. The Qwik City meta-framework provides routing and data loading.</p><p>We're assessing Qwik for performance-critical applications where initial load time is paramount. The framework is innovative but the ecosystem is young compared to React or Vue.</p><p><a href=""#"">Read more about Frontend Performance Patterns →</a></p>"
Zig,assess,languages & frameworks,new,"<p><strong>Zig</strong> is a systems programming language designed as a better C. It provides memory safety features, readable syntax, and excellent C interoperability without hidden control flow or allocations.</p><p>Zig's compile-time computation capabilities enable generic programming without the complexity of C++ templates. The language is used in projects like Bun and is gaining traction for systems programming.</p><p>We're assessing Zig for scenarios currently addressed by C, particularly for portable, high-performance code. The language is pre-1.0 but the community and tooling are growing.</p><p><a href=""#"">Read more about Systems Programming Evaluation →</a></p>"
MAUI,assess,languages & frameworks,no change,"<p><strong>.NET MAUI</strong> (Multi-platform App UI) is Microsoft's cross-platform framework for building native mobile and desktop applications from a single codebase. It's the evolution of Xamarin.Forms.</p><p>For organisations with .NET expertise wanting to build mobile applications, MAUI provides a path without learning entirely new platforms. The single project structure simplifies multi-platform development.</p><p>Assess MAUI for mobile applications when .NET skills are available and native platform features aren't extensively required. Compare with alternatives like React Native and Flutter for your specific requirements.</p><p><a href=""#"">Read more about Mobile Development Evaluation →</a></p>"
Angular,hold,languages & frameworks,moved out,"<p><strong>Angular</strong> has moved to Hold for new projects. While a capable framework with strong enterprise features, its ecosystem has not kept pace with React's. The complexity of RxJS, modules, and dependency injection creates a steeper learning curve.</p><p>For existing Angular applications, continued development is reasonable. The Angular team maintains active development and the framework remains suitable for large enterprise applications.</p><p>For new projects, we recommend React or Vue due to larger ecosystems, simpler mental models, and broader community support. Consider Angular only when specific enterprise features or existing expertise justify it.</p><p><a href=""#"">Read more about Frontend Framework Evaluation →</a></p>"
Create React App,hold,languages & frameworks,no change,"<p><strong>Create React App</strong> is deprecated and should not be used for new projects. The React team now recommends frameworks like Next.js, Remix, or build tools like Vite.</p><p>CRA's webpack configuration became outdated, and the lack of server-side rendering support limits modern React patterns. Vite provides a faster, more modern alternative for single-page applications.</p><p>For existing CRA projects, consider migration to Vite (relatively straightforward) or Next.js (more substantial but enables modern patterns). New React projects should start with Next.js or Vite.</p><p><a href=""#"">Read more about React Migration Guide →</a></p>"
